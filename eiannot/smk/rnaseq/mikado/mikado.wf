import os
from eicore.external_process.snakemake_helper import loadPreCmd


CFG=workflow.overwrite_configfile

BASE = os.path.dirname(eiannot.__file__)
RULES = os.path.join(BASE, "smk", "rnaseq")

REF = config["reference"]["genome"]
# TODO: this is hack that should be solved more neatly
if "out_dir" in config:
    OUT_DIR = config["out_dir"]
else:
    OUT_DIR = config["prepare"]["files"]["output_dir"]
if "threads" in config:
    THREADS = int(config["threads"])
else:
    THREADS = 1

if "mikado" in config:
    MIKADO_MODES=config["mikado"]["modes"]
else:
    MIKADO_MODES = ["split", "nosplit", "permissive", "lenient", "stringent"]

# Directory shortcuts
OUT_DIR_FULL = os.path.abspath(OUT_DIR)
MIKADO_DIR = os.path.join(OUT_DIR, "5-mikado")
MIKADO_DIR_FULL = os.path.abspath(MIKADO_DIR)
BLAST_DIR = os.path.join(MIKADO_DIR, "/blast")
BLAST_DIR_FULL = os.path.abspath(BLAST_DIR)
TDC_DIR = os.path.join(MIKADO_DIR, "transdecoder")
TDC_DIR_FULL = os.path.abspath(TDC_DIR)
PROD_DIR = os.path.join(MIKADO_DIR, "prodigal")
PROD_DIR_FULL = os.path.abspath(PROD_DIR)

CWD = os.getcwd()

BLASTX_TARGET = config["blastx"]["prot_db"]
BLASTX_MAX_TARGET_SEQS = config["blastx"]["max_target_seqs"]
BLASTX_EVALUE = config["blastx"]["evalue"]
BLASTX_CHUNKS = int(config["blastx"]["chunks"])
ASM_COLLECT = which("asm_collect.py")


if len(BLASTX_TARGET) > 0:
	CHUNK_ARRAY = [str(_).zfill(3) for _ in range(1,BLASTX_CHUNKS+1)]
else:
  CHUNK_ARRAY = []

rule all:
	input:
		os.path.join(MIKADO_DIR, "pick", "comparison.stats")
	output: touch(os.path.join(MIKADO_DIR, "all.done"))

rule clean:
	shell: "rm -rf {OUT_DIR}"

include: os.path.join(RULES, "mikado", "config.smk")
include: os.path.join(RULES, "mikado", "prepare.smk")
include: os.path.join(RULES, "mikado", "orfs.smk")
include: os.path.join(RULES, "mikado", "homology.smk")
include: os.path.join(RULES, "mikado", "serialise.smk")
include: os.path.join(RULES, "mikado", "pick.smk")



